//
// engine.cpp : Put all your graphics stuff in this file. This is kind of the graphics module.
// In here, you should type all your OpenGL commands, and you can also type code to handle
// input platform events (e.g to move the camera or react to certain shortcuts), writing some
// graphics related GUI options, and so on.
//

#include "engine.h"
#include "assimp_loading.h"
#include "buffer_management.h"
#include "resource_management.h"
#include <imgui.h>
#include <stb_image.h>
#include <stb_image_write.h>

mat4 TransformPositionScale(const vec3& pos, const vec3& scaleFactors)
{
	mat4 transform = glm::translate(pos);
	transform = glm::scale(transform, scaleFactors);
	return transform;
}

void getOpenGlInfo(App* app)
{
	app->GLInfo = {};
	app->GLInfo.version = (char*)glGetString(GL_VERSION);
	app->GLInfo.renderer = (char*)glGetString(GL_RENDERER);
	app->GLInfo.vendor = (char*)glGetString(GL_VENDOR);
	app->GLInfo.versionGLSL = (char*)glGetString(GL_SHADING_LANGUAGE_VERSION);

	GLint num_extensions;
	glGetIntegerv(GL_NUM_EXTENSIONS, &num_extensions);

	app->GLInfo.numExtensions = num_extensions;
	app->GLInfo.extensions = new char* [num_extensions];

	for (int i = 0; i < num_extensions; ++i)
	{
		app->GLInfo.extensions[i] = (char*)glGetStringi(GL_EXTENSIONS, GLuint(i));
	}
}

void OnGlError(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam)
{
	if (severity == GL_DEBUG_SEVERITY_NOTIFICATION)
		return;

	ELOG("OpenGL debug message: %s", message);

	switch (source)
	{
	case GL_DEBUG_SOURCE_API:             ELOG(" - source: GL_DEBUG_SOURCE_API"); break; // Calls to the OpenGL API
	case GL_DEBUG_SOURCE_WINDOW_SYSTEM:   ELOG(" - source: GL_DEBUG_SOURCE_WINDOW_SYSTEM"); break; // Calls to a window-system API
	case GL_DEBUG_SOURCE_SHADER_COMPILER: ELOG(" - source: GL_DEBUG_SOURCE_SHADER_COMPILER"); break; // A compiler for a shading language
	case GL_DEBUG_SOURCE_THIRD_PARTY:     ELOG(" - source: GL_DEBUG_SOURCE_THIRD_PARTY"); break; // An application associated with OpenGL
	case GL_DEBUG_SOURCE_APPLICATION:     ELOG(" - source: GL_DEBUG_SOURCE_APPLICATION"); break; // Generated by the user of this applicat
	case GL_DEBUG_SOURCE_OTHER:           ELOG(" - source: GL_DEBUG_SOURCE_OTHER"); break; // Some source that isn't one of these
	}

	switch (type)
	{
	case GL_DEBUG_TYPE_ERROR:               ELOG(" - type: GL_DEBUG_TYPE_ERROR"); break; // An error, typically from the API
	case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR: ELOG(" - type: GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR"); break; // Some behavior marked deprecated l
	case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR:  ELOG(" - type: GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR"); break; // Something has invoked undefined b
	case GL_DEBUG_TYPE_PORTABILITY:         ELOG(" - type: GL_DEBUG_TYPE_PORTABILITY"); break; // Some functionality the user relies upon
	case GL_DEBUG_TYPE_PERFORMANCE:         ELOG(" - type: GL_DEBUG_TYPE_PERFORMANCE"); break; // Code has triggered possible performance
	case GL_DEBUG_TYPE_MARKER:              ELOG(" - type: GL_DEBUG_TYPE_MARKER"); break; // Command stream annotation
	case GL_DEBUG_TYPE_PUSH_GROUP:          ELOG(" - type: GL_DEBUG_TYPE_PUSH_GROUP"); break; // Group pushing
	case GL_DEBUG_TYPE_POP_GROUP:           ELOG(" - type: GL_DEBUG_TYPE_POP_GROUP"); break; // foo
	case GL_DEBUG_TYPE_OTHER:               ELOG(" - type: GL_DEBUG_TYPE_OTHER"); break; // Some type that isn't one of these
	}

	switch (severity)
	{
	case GL_DEBUG_SEVERITY_HIGH:         ELOG(" - severity: GL_DEBUG_SEVERITY_HIGH"); break; // All OpenGL Errors, shader compilation/link
	case GL_DEBUG_SEVERITY_MEDIUM:       ELOG(" - severity: GL_DEBUG_SEVERITY_MEDIUM"); break; // Major performance warnings, shader compil
	case GL_DEBUG_SEVERITY_LOW:          ELOG(" - severity: GL_DEBUG_SEVERITY_LOW"); break; // Redundant state change performance warning,
	case GL_DEBUG_SEVERITY_NOTIFICATION: ELOG(" - severity: GL_DEBUG_SEVERITY_NOTIFICATION"); break; // Anything that isn't an error or per
	}
}

void GenerateTextureBuffer(App* app, GLuint& attachmentHandle)
{
	glGenTextures(1, &attachmentHandle);
	glBindTexture(GL_TEXTURE_2D, attachmentHandle);

	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, app->displaySize.x, app->displaySize.y, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
	glBindTexture(GL_TEXTURE_2D, 0);
}

void GenerateDepthBuffer(App* app, GLuint& attachmentHandle)
{
	glGenTextures(1, &attachmentHandle);
	glBindTexture(GL_TEXTURE_2D, attachmentHandle);

	glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT24, app->displaySize.x, app->displaySize.y, 0, GL_DEPTH_COMPONENT, GL_FLOAT, NULL);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
}

void GenFrameBuffers(App* app)
{
	// Direct lighting to render texture buffer -----------------------------------------------------------------------
	GenerateTextureBuffer(app, app->frameBufferAttachmentHandle);
	GenerateDepthBuffer(app, app->depthAttachmentHandle);

	glGenFramebuffers(1, &app->directFrameBufferHandle);
	glBindFramebuffer(GL_FRAMEBUFFER, app->directFrameBufferHandle);

	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, app->frameBufferAttachmentHandle, 0);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, app->depthAttachmentHandle, 0);

	GLenum directFramebufferStatus = glCheckFramebufferStatus(GL_FRAMEBUFFER);
	if (directFramebufferStatus != GL_FRAMEBUFFER_COMPLETE)
	{
		switch (directFramebufferStatus)
		{
		case GL_FRAMEBUFFER_UNDEFINED:ELOG("GL_FRAMEBUFFER_UNDEFINED"); break;
		case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT:ELOG("GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT"); break;
		case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:ELOG("GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"); break;
		case GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER:ELOG("GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER"); break;
		case GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER:ELOG("GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER"); break;
		case GL_FRAMEBUFFER_UNSUPPORTED:ELOG("GL_FRAMEBUFFER_UNSUPPORTED"); break;
		case GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:ELOG("GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"); break;
		case GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS:ELOG("GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS"); break;
		default:ELOG("Unknown framebuffer status error");
		}
	}

	glBindFramebuffer(GL_FRAMEBUFFER, 0);

	// Defferred lighting to render texture buffer --------------------------------------------------------------------

	GenerateTextureBuffer(app, app->albedoAttachmentHandle);
	GenerateTextureBuffer(app, app->normalsAttachmentHandle);
	GenerateTextureBuffer(app, app->positionAttachmentHandle);
	GenerateTextureBuffer(app, app->deferredAttachmentHandle);
	GenerateTextureBuffer(app, app->brightColorsAttachmentHandle);
	GenerateTextureBuffer(app, app->halfBlurredColorsAttachmentHandle);
	GenerateTextureBuffer(app, app->blurredColorsAttachmentHandle);
	GenerateTextureBuffer(app, app->mixedBlurImage);

	//Create the Frame Buffer where all the textures will be stored
	glGenFramebuffers(1, &app->deferredFrameBufferHandle);
	glBindFramebuffer(GL_FRAMEBUFFER, app->deferredFrameBufferHandle);

	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, app->albedoAttachmentHandle, 0);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT1, GL_TEXTURE_2D, app->normalsAttachmentHandle, 0);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT2, GL_TEXTURE_2D, app->positionAttachmentHandle, 0);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT3, GL_TEXTURE_2D, app->deferredAttachmentHandle, 0);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT4, GL_TEXTURE_2D, app->brightColorsAttachmentHandle, 0);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT5, GL_TEXTURE_2D, app->halfBlurredColorsAttachmentHandle, 0);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT6, GL_TEXTURE_2D, app->blurredColorsAttachmentHandle, 0);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT7, GL_TEXTURE_2D, app->mixedBlurImage, 0);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, app->depthAttachmentHandle, 0);

	GLenum framebufferStatus = glCheckFramebufferStatus(GL_FRAMEBUFFER);
	if (framebufferStatus != GL_FRAMEBUFFER_COMPLETE)
	{
		switch (framebufferStatus)
		{
		case GL_FRAMEBUFFER_UNDEFINED:ELOG("GL_FRAMEBUFFER_UNDEFINED"); break;
		case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT:ELOG("GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT"); break;
		case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:ELOG("GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"); break;
		case GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER:ELOG("GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER"); break;
		case GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER:ELOG("GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER"); break;
		case GL_FRAMEBUFFER_UNSUPPORTED:ELOG("GL_FRAMEBUFFER_UNSUPPORTED"); break;
		case GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE:ELOG("GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"); break;
		case GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS:ELOG("GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS"); break;
		default:ELOG("Unknown framebuffer status error");
		}
	}

	glBindFramebuffer(GL_FRAMEBUFFER, 0);
}

void InitPrimitiveGeometry(GLuint& geometryVao, const VertexV3V2 vertices[], GLsizeiptr verticesSize, const u16 indices[], GLsizeiptr indicesSize)
{
	GLuint embeddedVerticesIdx;
	GLuint embeddedElementsIdx;

	//VBO
	glGenBuffers(1, &embeddedVerticesIdx);
	glBindBuffer(GL_ARRAY_BUFFER, embeddedVerticesIdx);
	glBufferData(GL_ARRAY_BUFFER, verticesSize, vertices, GL_STATIC_DRAW);
	glBindBuffer(GL_ARRAY_BUFFER, 0);

	//EBO
	glGenBuffers(1, &embeddedElementsIdx);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, embeddedElementsIdx);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, indicesSize, indices, GL_STATIC_DRAW);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);

	//VAO, we use this in render, in FindVAOs
	glGenVertexArrays(1, &geometryVao);
	glBindVertexArray(geometryVao);
	glBindBuffer(GL_ARRAY_BUFFER, embeddedVerticesIdx);

	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(VertexV3V2), (void*)0);  //The first parameter is 0 because this is
	glEnableVertexAttribArray(0);                                                   //the "location" we declare in the shader
	glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(VertexV3V2), (void*)12); //The first parameter is 1 because this is
	glEnableVertexAttribArray(1);                                                   //the "location" we declare in the shader

	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, embeddedElementsIdx);
	glBindVertexArray(0);
}

u32 LoadCubemapTexture(App* app, std::vector<std::string> cubemapTexturePaths)
{
	for (Cubemap cubemap : app->cubemaps)
	{
		bool texturesMatch = true;

		for (int i = 0; i < cubemap.filepaths.size(); i++)
		{
			if (cubemap.filepaths[i] != cubemapTexturePaths[i])
			{
				texturesMatch = false;
			}
		}

		if (texturesMatch)
		{
			return cubemap.handle;
		}
	}

	unsigned int textureID;
	glGenTextures(1, &textureID);
	glBindTexture(GL_TEXTURE_CUBE_MAP, textureID);

	int width, height, nrChannels;
	for (unsigned int i = 0; i < cubemapTexturePaths.size(); i++)
	{
		stbi_set_flip_vertically_on_load(false);
		unsigned char* data = stbi_load(cubemapTexturePaths[i].c_str(), &width, &height, &nrChannels, 0);
		if (data)
		{
			glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i,
				0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data
			);
			stbi_image_free(data);
		}
		else
		{
			ELOG("Cubemap tex failed to load at path: %s", cubemapTexturePaths[i].c_str());
			stbi_image_free(data);
		}
	}
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);

	return textureID;
}

void Init(App* app)
{
	if (GLVersion.major > 4 || (GLVersion.major == 4 && GLVersion.minor >= 3))
	{
		glDebugMessageCallback(OnGlError, app);
	}

	getOpenGlInfo(app);

	// Primitive geometry init ----------------------------------------------------------------------------------------

	const VertexV3V2 targetQuad_vertices[] =
	{
		{ glm::vec3(-1.0, -1.0, 0.0),   glm::vec2(0.0, 0.0) }, //bottom-left
		{ glm::vec3(1.0, -1.0, 0.0),    glm::vec2(1.0, 0.0) }, //bottom-right
		{ glm::vec3(1.0, 1.0, 0.0),     glm::vec2(1.0, 1.0) }, //top-right
		{ glm::vec3(-1.0, 1.0, 0.0),    glm::vec2(0.0, 1.0) } //top-left
	};
	const u16 targetQuad_indices[] =
	{
		0,1,2,
		0,2,3
	};

	const VertexV3V2 cube_vertices[] =
	{
		{ glm::vec3(-1.0, 1.0, -1.0),   glm::vec2(0.0, 0.0) }, //0
		{ glm::vec3(-1.0, -1.0, -1.0),  glm::vec2(0.0, 0.0) }, //1
		{ glm::vec3(1.0, 1.0, -1.0),    glm::vec2(0.0, 0.0) }, //2
		{ glm::vec3(1.0, -1.0, -1.0),   glm::vec2(0.0, 0.0) }, //3
		{ glm::vec3(1.0, 1.0, 1.0),     glm::vec2(0.0, 0.0) }, //4
		{ glm::vec3(1.0, -1.0, 1.0),    glm::vec2(0.0, 0.0) }, //5
		{ glm::vec3(-1.0, 1.0, 1.0),    glm::vec2(0.0, 0.0) }, //6
		{ glm::vec3(-1.0, -1.0, 1.0),   glm::vec2(0.0, 0.0) }, //7
	};
	const u16 cube_indices[] =
	{
		//Tri direction is counter clockwise

		0,1,2, 1,3,2, //Front
		2,3,5, 2,5,4, //Right
		4,5,7, 4,7,6, //Back
		0,6,7, 0,7,1, //Left
		0,2,6, 2,4,6, //Top
		1,7,3, 3,7,5  //Bottom
	};

	const VertexV3V2 sphere_vertices[] =
	{
		{ glm::vec3(0.000000f, 1.000000f, 0.000000f), glm::vec2(0.0, 0.0) }, // 0
		{ glm::vec3(0.707107f,  0.707107f, 0.000000f), glm::vec2(0.0, 0.0) }, // 1
		{ glm::vec3(0.500000f, 0.707107f, 0.500000f), glm::vec2(0.0, 0.0) }, // 2
		{ glm::vec3(0.000000f, 0.707107f, 0.707107f), glm::vec2(0.0, 0.0) }, // 3
		{ glm::vec3(-0.500000f, 0.707107f, 0.500000f), glm::vec2(0.0, 0.0) }, // 4
		{ glm::vec3(-0.707107f, 0.707107f, 0.000000f), glm::vec2(0.0, 0.0) }, // 5
		{ glm::vec3(-0.500000f, 0.707107f, -0.500000f), glm::vec2(0.0, 0.0) }, // 6
		{ glm::vec3(0.000000f, 0.707107f, -0.707107f), glm::vec2(0.0, 0.0) }, // 7
		{ glm::vec3(0.500000f, 0.707107f, -0.500000f), glm::vec2(0.0, 0.0) }, // 8

		{ glm::vec3(1.000000f, 0.000000f, 0.000000f), glm::vec2(0.0, 0.0) }, // 9
		{ glm::vec3(0.707107f, 0.000000f, 0.707107f), glm::vec2(0.0, 0.0) }, // 10
		{ glm::vec3(0.000000f, 0.000000f, 1.000000f), glm::vec2(0.0, 0.0) }, // 11
		{ glm::vec3(-0.707107f, 0.000000f, 0.707107f), glm::vec2(0.0, 0.0) }, // 12
		{ glm::vec3(-1.000000f, 0.000000f, 0.000000f), glm::vec2(0.0, 0.0) }, // 13
		{ glm::vec3(-0.707107f, 0.000000f, -0.707107f), glm::vec2(0.0, 0.0) }, // 14
		{ glm::vec3(0.000000f, 0.000000f, -1.000000f), glm::vec2(0.0, 0.0) }, // 15
		{ glm::vec3(0.707107f, 0.000000f, -0.707107f), glm::vec2(0.0, 0.0) }, // 16

		{ glm::vec3(0.707107f, -0.707107f, 0.000000f), glm::vec2(0.0, 0.0) }, // 17
		{ glm::vec3(0.500000f, -0.707107f, 0.500000f), glm::vec2(0.0, 0.0) }, // 18
		{ glm::vec3(0.000000f, -0.707107f, 0.707107f), glm::vec2(0.0, 0.0) }, // 19
		{ glm::vec3(-0.500000f, -0.707107f, 0.500000f), glm::vec2(0.0, 0.0) }, // 20
		{ glm::vec3(-0.707107f, -0.707107f, 0.000000f), glm::vec2(0.0, 0.0) }, // 21
		{ glm::vec3(-0.500000f, -0.707107f, -0.500000f), glm::vec2(0.0, 0.0) }, // 22
		{ glm::vec3(0.000000f, -0.707107f, -0.707107f), glm::vec2(0.0, 0.0) }, // 23
		{ glm::vec3(0.500000f, -0.707107f, -0.500000f), glm::vec2(0.0, 0.0) }, // 24

		{ glm::vec3(0.000000f, -1.000000f, 0.000000f), glm::vec2(0.0, 0.0) }, // 25
	};
	const u16 sphere_indices[] =
	{
		//Tri direction is counter clockwise

		// Top cap (first ring)
		0, 1, 2,
		0, 2, 3,
		0, 3, 4,
		0, 4, 5,
		0, 5, 6,
		0, 6, 7,
		0, 7, 8,
		0, 8, 1,

		// Middle rings (ring 1 to 2)
		1, 9, 2,
		2, 9, 10,
		2, 10, 3,
		3, 10, 11,
		3, 11, 4,
		4, 11, 12,
		4, 12, 5,
		5, 12, 13,
		5, 13, 6,
		6, 13, 14,
		6, 14, 7,
		7, 14, 15,
		7, 15, 8,
		8, 15, 16,
		8, 16, 1,
		1, 16, 9,

		// Ring 2 to 3
		9, 17, 10,
		10, 17, 18,
		10, 18, 11,
		11, 18, 19,
		11, 19, 12,
		12, 19, 20,
		12, 20, 13,
		13, 20, 21,
		13, 21, 14,
		14, 21, 22,
		14, 22, 15,
		15, 22, 23,
		15, 23, 16,
		16, 23, 24,
		16, 24, 9,
		9, 24, 17,

		// Bottom cap
		25, 18, 17,
		25, 19, 18,
		25, 20, 19,
		25, 21, 20,
		25, 22, 21,
		25, 23, 22,
		25, 24, 23,
		25, 17, 24,
	};

	InitPrimitiveGeometry(app->targetQuad_vao, targetQuad_vertices, sizeof(targetQuad_vertices), targetQuad_indices, sizeof(targetQuad_indices));
	InitPrimitiveGeometry(app->cube_vao, cube_vertices, sizeof(cube_vertices), cube_indices, sizeof(cube_indices));
	InitPrimitiveGeometry(app->sphere_vao, sphere_vertices, sizeof(sphere_vertices), sphere_indices, sizeof(sphere_indices));
	InitPrimitiveGeometry(app->skybox_vao, cube_vertices, sizeof(cube_vertices), cube_indices, sizeof(cube_indices));

	// Programs init --------------------------------------------------------------------------------------------------

	// Dice image
	app->texturedGeometryProgramIdx = LoadProgram(app, "shaders.glsl", "TEXTURED_GEOMETRY"); //This is used to render a plane
	Program& texturedGeometryProgram = app->programs[app->texturedGeometryProgramIdx];
	app->programUniformTexture = glGetUniformLocation(texturedGeometryProgram.handle, "uTexture");

	// Direct Mode
	app->texturedMeshProgramIdx = LoadProgram(app, "shaders.glsl", "SHOW_TEXTURED_MESH"); //This is used to render a mesh
	Program& texturedMeshProgram = app->programs[app->texturedMeshProgramIdx];

	app->texturedMeshProgram_uTexture = glGetUniformLocation(texturedMeshProgram.handle, "uTexture");

	// Render textures
	app->renderTexturesProgramIdx = LoadProgram(app, "render_textures_shader.glsl", "RENDER_TEXTURES"); //This is used to render a mesh
	Program& renderTexturesProgram = app->programs[app->renderTexturesProgramIdx];

	app->renderTexturesProgram_uTexture = glGetUniformLocation(renderTexturesProgram.handle, "uTexture");
	app->renderTexturesProgram_cubeTexture = glGetUniformLocation(renderTexturesProgram.handle, "cubeTexture");

	// Deferred Lighting
	app->deferredLightingProgramIdx = LoadProgram(app, "render_textures_shader.glsl", "DEFERRED_LIGHTING_PASS"); //This is used for the deferred lighting pass
	Program& deferredLightingProgram = app->programs[app->deferredLightingProgramIdx];

	app->deferredLightingPass_posTexture = glGetUniformLocation(deferredLightingProgram.handle, "positionTexture");
	app->deferredLightingPass_normalTexture = glGetUniformLocation(deferredLightingProgram.handle, "normalTexture");
	app->deferredLightingPass_albedoTexture = glGetUniformLocation(deferredLightingProgram.handle, "albedoTexture");

	// Lights Visualization
	app->lightVisualizationProgramIdx = LoadProgram(app, "light_visualization_shader.glsl", "LIGHT_VISUALIZATION"); //This is used to render a mesh
	Program& lightVisProgram = app->programs[app->lightVisualizationProgramIdx];

	// Bloom
	app->blurPassProgramIdx = LoadProgram(app, "bloom_pass.glsl", "BLUR_PASS");
	Program& blurProgram = app->programs[app->blurPassProgramIdx];

	app->bloom_brightColorImage = glGetUniformLocation(blurProgram.handle, "brightColorImage");
	app->bloom_horizontalLocation = glGetUniformLocation(blurProgram.handle, "horizontal");
	app->bloomStrengthLocation = glGetUniformLocation(blurProgram.handle, "strength");
	app->bloomIterationsLocation = glGetUniformLocation(blurProgram.handle, "iterations");

	// Bloom mix
	app->bloomMixProgramIdx = LoadProgram(app, "bloom_pass.glsl", "MIX_BLOOM");
	Program& bloomMixProgram = app->programs[app->bloomMixProgramIdx];

	app->bloom_blurredImage = glGetUniformLocation(bloomMixProgram.handle, "blurredImage");
	app->bloom_originalImage = glGetUniformLocation(bloomMixProgram.handle, "originalColor");	

	//Skybox
	app->skyboxProgramIdx = LoadProgram(app, "skybox_shader.glsl", "SKYBOX"); //This is used to render a mesh
	Program& skyboxProgram = app->programs[app->skyboxProgramIdx];
	app->skybox_uTexture = glGetUniformLocation(skyboxProgram.handle, "uTexture");
	app->skybox_uMatrix = glGetUniformLocation(skyboxProgram.handle, "uWorldViewProjectionMatrix");

	// Camera init ----------------------------------------------------------------------------------------------------

	app->camera = Camera{ mat4(1.0),
						  vec3(0),
						  10.0f,
						  (float)app->displaySize.x / (float)app->displaySize.y,
						  0.1f,
						  1000.0f,
						  60.0f
	};
	app->camera.transformation = glm::translate(app->camera.transformation, vec3(1, 4, 5));
	app->camera.transformation = glm::rotate(app->camera.transformation, glm::radians(12.5f), vec3(0, 1, 0) * (glm::mat3)app->camera.transformation);
	app->camera.transformation = glm::rotate(app->camera.transformation, glm::radians(-30.0f), vec3(1, 0, 0));

	// Textures init --------------------------------------------------------------------------------------------------

	app->diceTexIdx = LoadTexture2D(app, "dice.png");
	app->whiteTexIdx = LoadTexture2D(app, "color_white.png");
	app->blackTexIdx = LoadTexture2D(app, "color_black.png");
	app->normalTexIdx = LoadTexture2D(app, "color_normal.png");
	app->magentaTexIdx = LoadTexture2D(app, "color_magenta.png");

	std::vector<std::string> meadowPaths =				{ "Skyboxes/Meadow/posx.jpg",
											 "Skyboxes/Meadow/negx.jpg",
											 "Skyboxes/Meadow/posy.jpg",
											 "Skyboxes/Meadow/negy.jpg",
											 "Skyboxes/Meadow/posz.jpg",
											 "Skyboxes/Meadow/negz.jpg" };
	std::vector<std::string> langholmenPaths =			{ "Skyboxes/Langholmen/posx.jpg",
												 "Skyboxes/Langholmen/negx.jpg",
												 "Skyboxes/Langholmen/posy.jpg",
												 "Skyboxes/Langholmen/negy.jpg",
												 "Skyboxes/Langholmen/posz.jpg",
												 "Skyboxes/Langholmen/negz.jpg" };
	std::vector<std::string> sfparkPaths =				{ "Skyboxes/SF_Park/posx.jpg",
											 "Skyboxes/SF_Park/negx.jpg",
											 "Skyboxes/SF_Park/posy.jpg",
											 "Skyboxes/SF_Park/negy.jpg",
											 "Skyboxes/SF_Park/posz.jpg",
											 "Skyboxes/SF_Park/negz.jpg" };
	std::vector<std::string> bikiniBottomPaths =		{ "Skyboxes/BikiniBottom/posx.jpg",
												   "Skyboxes/BikiniBottom/negx.jpg",
												   "Skyboxes/BikiniBottom/posy.jpg",
												   "Skyboxes/BikiniBottom/negy.jpg",
												   "Skyboxes/BikiniBottom/posz.jpg",
												   "Skyboxes/BikiniBottom/negz.jpg" };
	std::vector<std::string> hornstullsStrandPaths =	{ "Skyboxes/HornstullsStrandNight/posx.jpg",
													   "Skyboxes/HornstullsStrandNight/negx.jpg",
													   "Skyboxes/HornstullsStrandNight/posy.jpg",
													   "Skyboxes/HornstullsStrandNight/negy.jpg",
													   "Skyboxes/HornstullsStrandNight/posz.jpg",
													   "Skyboxes/HornstullsStrandNight/negz.jpg" };
	std::vector<std::string> pondPaths =				{ "Skyboxes/PondNight/posx.jpg",
										   "Skyboxes/PondNight/negx.jpg",
										   "Skyboxes/PondNight/posy.jpg",
										   "Skyboxes/PondNight/negy.jpg",
										   "Skyboxes/PondNight/posz.jpg",
										   "Skyboxes/PondNight/negz.jpg" };
	std::vector<std::string> powerLinesPaths =			{ "Skyboxes/PowerlinesNight/posx.jpg",
												 "Skyboxes/PowerlinesNight/negx.jpg",
												 "Skyboxes/PowerlinesNight/posy.jpg",
												 "Skyboxes/PowerlinesNight/negy.jpg",
												 "Skyboxes/PowerlinesNight/posz.jpg",
												 "Skyboxes/PowerlinesNight/negz.jpg" };
	std::vector<std::string> swedishRoyalCastlePaths =	{ "Skyboxes/SwedishRoyalCastleNight/posx.jpg",
														 "Skyboxes/SwedishRoyalCastleNight/negx.jpg",
														 "Skyboxes/SwedishRoyalCastleNight/posy.jpg",
														 "Skyboxes/SwedishRoyalCastleNight/negy.jpg",
														 "Skyboxes/SwedishRoyalCastleNight/posz.jpg",
														 "Skyboxes/SwedishRoyalCastleNight/negz.jpg" };
	std::vector<std::string> yokohamaPaths =			{ "Skyboxes/YokohamaNight/posx.jpg",
											   "Skyboxes/YokohamaNight/negx.jpg",
											   "Skyboxes/YokohamaNight/posy.jpg",
											   "Skyboxes/YokohamaNight/negy.jpg",
											   "Skyboxes/YokohamaNight/posz.jpg",
											   "Skyboxes/YokohamaNight/negz.jpg" };

	app->meadowSkyboxTexIdx =				LoadCubemapTexture(app, meadowPaths);
	app->langholmenSkyboxTexIdx =			LoadCubemapTexture(app, langholmenPaths);
	app->SFParkSkyboxTexIdx =				LoadCubemapTexture(app, sfparkPaths);
	app->bikiniBottomSkyboxTexIdx =			LoadCubemapTexture(app, bikiniBottomPaths);
	app->hornstullsStrandSkyboxTexIdx =		LoadCubemapTexture(app, hornstullsStrandPaths);
	app->pondSkyboxTexIdx =					LoadCubemapTexture(app, pondPaths);
	app->powerLinesSkyboxTexIdx =			LoadCubemapTexture(app, powerLinesPaths);
	app->swedishRoyalCastleSkyboxTexIdx =	LoadCubemapTexture(app, swedishRoyalCastlePaths);
	app->yokohamaSkyboxTexIdx =				LoadCubemapTexture(app, yokohamaPaths);

	// Models init ----------------------------------------------------------------------------------------------------

	app->patrickModel = LoadModel(app, "Patrick/Patrick.obj");
	app->planeModel = LoadModel(app, "Plane/Plane.obj", GL_NEAREST);

	// Entities placement ---------------------------------------------------------------------------------------------

	app->entityList.push_back({ TransformPositionScale(vec3(0, 1.8, 0), vec3(0.5)), app->patrickModel, 0 });
	app->entityList.push_back({ TransformPositionScale(vec3(2.5, 1.8, 0), vec3(0.3)), app->patrickModel, 20 });
	app->entityList.push_back({ TransformPositionScale(vec3(0, 1.8, -2.5), vec3(0.2)), app->patrickModel, 70 });

	app->entityList.push_back({ TransformPositionScale(vec3(0, 0, 0), vec3(5.0)), app->planeModel, 10 });

	// Lights placement -----------------------------------------------------------------------------------------------

	app->lightList.push_back({ LightType_Point, 1, vec3(1,0,0), vec3(0), vec3(0,0.1,0) });
	app->lightList.push_back({ LightType_Point, 1, vec3(0,1,0), vec3(0), vec3(1,3,1.5) });
	app->lightList.push_back({ LightType_Point, 1, vec3(0,0,1), vec3(0), vec3(-1,3,1.5) });

	app->lightList.push_back({ LightType_Directional, 1, vec3(1,1,0), vec3(0,-1, 0), vec3(0,5,0) });

	// Buffer creation ------------------------------------------------------------------------------------------------

	//Get info to create and use uniforms buffer
	glGetIntegerv(GL_MAX_UNIFORM_BLOCK_SIZE, &app->maxUniformBufferSize);
	glGetIntegerv(GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT, &app->uniformBlockAlignment);

	//Create the buffer to pass the transforms to the shader
	app->uniformsBuffer = CreateConstantBuffer(app->maxUniformBufferSize);
	app->lightMatricesBuffer = CreateConstantBuffer(app->maxUniformBufferSize);

	GenFrameBuffers(app);

	// Set default render mode ----------------------------------------------------------------------------------------

	app->mode = Mode_DeferredRenderTextures;
	app->renderTexMode = RendTexMode_DeferredBloom;
	app->currentSkybox = 0;
}

void RenderingModesWindow(App* app)
{
	ImGui::Begin("Rendering modes");

	const char* skyboxTags[] = { "Meadow", "Langholmen", "San Francisco Park", "Bikini Bottom", "HornstullsStrand Night", "Pond Night", "Powerlines Night", "Swedish Royal Castle Night", "Yokohama Night" };
	if (ImGui::BeginCombo("Skybox", skyboxTags[app->currentSkybox]))
	{
		for (int n = 0; n < ARRAY_COUNT(skyboxTags); n++)
		{
			bool selected = (n == app->currentSkybox);

			if (ImGui::Selectable(skyboxTags[n], selected))
				app->currentSkybox = n;

			if (selected)
				ImGui::SetItemDefaultFocus();
		}
		ImGui::EndCombo();
	}

	ImGui::Dummy(ImVec2(0.0f, 10.0f)); //Spacing

	const char* modeTags[] = { "Textured Quad", "Direct Meshes", "Direct Frame Buffer", "Defferred Shading" };
	if (ImGui::BeginCombo("Render mode", modeTags[app->mode]))
	{
		for (int n = 0; n < ARRAY_COUNT(modeTags); n++)
		{
			bool selected = (n == app->mode);

			if (ImGui::Selectable(modeTags[n], selected))
				app->mode = Mode(n);

			if (selected)
				ImGui::SetItemDefaultFocus();
		}
		ImGui::EndCombo();
	}

	if (app->mode == Mode_DeferredRenderTextures)
	{
		const char* renderTexTags[] = { "Albedo", "Normals", "Position", "Depth", "Deferred Only", "Deferred + Bloom (Final image)"};
		if (ImGui::BeginCombo("Render Textures", renderTexTags[app->renderTexMode]))
		{
			for (int n = 0; n < ARRAY_COUNT(renderTexTags); n++)
			{
				bool selected = (n == app->renderTexMode);

				if (ImGui::Selectable(renderTexTags[n], selected))
					app->renderTexMode = RenderTextureMode(n);

				if (selected)
					ImGui::SetItemDefaultFocus();
			}
			ImGui::EndCombo();
		}
	}

	ImGui::SliderFloat("Bloom strength", (float*)&app->bloomStrength, 0.0f, 100.0f, "%.1f");
	ImGui::SliderInt("Bloom iterations", (int*)&app->bloomIterations, 0, 50, "%i");

	ImGui::End();
}
void OpenGLInfoWindow(App* app)
{
	ImGui::Begin("OpenGL info");
	ImGui::Text("ImGui version: %s", ImGui::GetVersion());

	ImGui::Text("GL Version: %s", app->GLInfo.version);
	ImGui::Text("Renderer Version: %s", app->GLInfo.renderer);
	ImGui::Text("Vendor: %s", app->GLInfo.vendor);
	ImGui::Text("GLSL Version: %s", app->GLInfo.versionGLSL);

	std::string dropdownTitle = "Extensions [" + std::to_string(app->GLInfo.numExtensions) + "]";
	if (ImGui::CollapsingHeader(dropdownTitle.c_str(), ImGuiTreeNodeFlags_None))
	{
		for (int i = 0; i < app->GLInfo.numExtensions; i++)
		{
			std::string name = "[" + std::to_string(i) + "] " + app->GLInfo.extensions[i];
			ImGui::Text("%s", name.c_str());
		}
	}

	ImGui::End();
}
void InspectorWindow(App* app, Entity& selectedEntity)
{
	ImGui::Begin("Inspector");

	ImGui::SliderInt("Reflectiveness", (int*)&selectedEntity.reflectiveness, 0, 100, "%d%%");

	ImGui::End();
}
void InspectorWindow(App* app, Light& selectedLight)
{
	ImGui::Begin("Inspector");

	ImGui::Text("Transformation");
	ImGui::Separator();

	ImGui::DragFloat3("Light Position", (float*)&selectedLight.position, 0.2f);
	
	if (selectedLight.type == 0)
		ImGui::DragFloat3("Light Direction", (float*)&selectedLight.direction, 0.2f);

	ImGui::Spacing();

	ImGui::Text("Light Properties");
	ImGui::Separator();

	ImGui::DragInt("Light Strength", (int*)&selectedLight.strength, 1, 0, 9999, "%d", ImGuiSliderFlags_AlwaysClamp);

	ImGui::Spacing();

	ImGui::Text("Light Color");
	ImGui::ColorPicker3("Target Color", (float*)&selectedLight.color);

	ImGui::End();
}
void HierarchyWindow(App* app)
{
	ImGui::Begin("Hierarchy");

	ImGui::Text("Entities");
	ImGui::Separator();

	for (int i = 0; i < app->entityList.size(); i++)
	{
		std::string name = "Entity " + std::to_string(i);
		if (ImGui::Selectable(name.c_str(), app->selectedEntityIndex == i))
		{
			app->selectedObjType = false;
			app->selectedEntityIndex = i;
			app->selectedLightsIndex = -1;
		}
	}

	ImGui::Dummy(ImVec2(0.0f, 20.0f)); //Spacing

	ImGui::Text("Lights");
	ImGui::Separator();
	for (int i = 0; i < app->lightList.size(); i++)
	{
		std::string name = "Light " + std::to_string(i);
		if (ImGui::Selectable(name.c_str(), app->selectedLightsIndex == i))
		{
			app->selectedObjType = true;
			app->selectedEntityIndex = -1;
			app->selectedLightsIndex = i;
		}
	}

	if (app->selectedObjType)
	{
		InspectorWindow(app, app->lightList.at(app->selectedLightsIndex));
	}
	else
	{
		InspectorWindow(app, app->entityList.at(app->selectedEntityIndex));
	}

	ImGui::End();
}
void InformationWindow(App* app)
{
	ImGui::Begin("Info");
	ImGui::Text("FPS: %f", 1.0f / app->deltaTime);
	ImGui::Separator();

	ImGui::Dummy(ImVec2(0.0f, 20.0f)); //Spacing

	ImGui::Text("Controls");
	ImGui::Separator();
	ImGui::Spacing();

	ImGui::Text("Click on the main window to select it as the active window.");
	ImGui::Spacing();
	ImGui::Spacing();
	ImGui::Text("With the main window active, hold Right Click to operate the camera view.");
	ImGui::Spacing();
	ImGui::Spacing();
	ImGui::Text("While holding right click, move the mouse to look around.");
	ImGui::Text("While holding right click, use WASD to move.");
	ImGui::Text("Use the Space Bar and C to go up and down.");

	ImGui::Dummy(ImVec2(0.0f, 20.0f)); //Spacing

	if (ImGui::CollapsingHeader("Camera transformation matrix", ImGuiTreeNodeFlags_None))
	{
		Camera& cam = app->camera;

		if (ImGui::BeginTable("", 4))
		{
			ImGui::TableNextRow();
			ImGui::TableSetColumnIndex(0);
			ImGui::Text("%f", cam.transformation[0][0]);
			ImGui::Text("%f", cam.transformation[1][0]);
			ImGui::Text("%f", cam.transformation[2][0]);
			ImGui::Text("%f", cam.transformation[3][0]);
			ImGui::TableSetColumnIndex(1);
			ImGui::Text("%f", cam.transformation[0][1]);
			ImGui::Text("%f", cam.transformation[1][1]);
			ImGui::Text("%f", cam.transformation[2][1]);
			ImGui::Text("%f", cam.transformation[3][1]);
			ImGui::TableSetColumnIndex(2);
			ImGui::Text("%f", cam.transformation[0][2]);
			ImGui::Text("%f", cam.transformation[1][2]);
			ImGui::Text("%f", cam.transformation[2][2]);
			ImGui::Text("%f", cam.transformation[3][2]);
			ImGui::TableSetColumnIndex(3);
			ImGui::Text("%f", cam.transformation[0][3]);
			ImGui::Text("%f", cam.transformation[1][3]);
			ImGui::Text("%f", cam.transformation[2][3]);
			ImGui::Text("%f", cam.transformation[3][3]);
		}
		ImGui::EndTable();
	}

	ImGui::End();
}

void Gui(App* app)
{
	RenderingModesWindow(app);

	OpenGLInfoWindow(app);

	HierarchyWindow(app);

	InformationWindow(app);
}

void ProgramHotReload(App* app)
{
	for (u64 i = 0; i < app->programs.size(); ++i)
	{
		Program& program = app->programs[i];
		u64 currentTimestamp = GetFileLastWriteTimestamp(program.filepath.c_str());
		if (currentTimestamp > program.lastWriteTimestamp)
		{
			glDeleteProgram(program.handle);

			String programSource = ReadTextFile(program.filepath.c_str());
			const char* programName = program.programName.c_str();
			program.handle = CreateProgramFromSource(programSource, programName);
			program.lastWriteTimestamp = currentTimestamp;
		}
	}
}

void HandleInput(App* app, Camera& cam)
{
	if (app->input.mouseScrollDelta.y != 0)
	{
		float scrollSensitivity = 0.4f;

		float distanceCalc = app->input.mouseScrollDelta.y * scrollSensitivity;
		if ((cam.pivotDistance - distanceCalc) > 0.5f)
		{
			cam.pivotDistance -= distanceCalc;
			cam.transformation[3] = vec4(cam.pivot + vec3(cam.transformation[2]) * cam.pivotDistance, 1);
		}
	}

	if (app->input.mouseButtons[LEFT] == BUTTON_PRESSED)
	{
		float xIncrease = app->input.mouseDelta.x;
		float yIncrease = app->input.mouseDelta.y;

		float orbitSensitivity = 0.1f;
		
		//Get close
		cam.transformation[3] = vec4(cam.pivot, 1);

		//Rotate
		cam.transformation = glm::rotate(cam.transformation, glm::radians(-xIncrease * orbitSensitivity), vec3(0, 1, 0) * (glm::mat3)cam.transformation);
		cam.transformation = glm::rotate(cam.transformation, glm::radians(-yIncrease * orbitSensitivity), vec3(1, 0, 0));

		//Get back
		cam.transformation[3] = vec4(cam.pivot + vec3(cam.transformation[2]) * cam.pivotDistance, 1);
	}

	if (app->input.mouseButtons[RIGHT] == BUTTON_PRESSED)
	{
		glm::mat3 rotMat = glm::mat3(cam.transformation);
		vec3 position = vec3(cam.transformation[3]);

		vec3 right = rotMat[0];
		vec3 up = rotMat[1];
		vec3 forward = -rotMat[2]; //in OpenGL is back

		float movementSpeed = 0.1f;
		if (app->input.keys[K_W] == BUTTON_PRESSED)
		{
			vec3 vecInRefFrame = forward * movementSpeed * rotMat;

			cam.transformation = glm::translate(cam.transformation, vecInRefFrame);
		}
		if (app->input.keys[K_A] == BUTTON_PRESSED)
		{
			vec3 vecInRefFrame = -right * movementSpeed * rotMat;

			cam.transformation = glm::translate(cam.transformation, vecInRefFrame);
		}
		if (app->input.keys[K_S] == BUTTON_PRESSED)
		{
			vec3 vecInRefFrame = -forward * movementSpeed * rotMat;

			cam.transformation = glm::translate(cam.transformation, vecInRefFrame);
		}
		if (app->input.keys[K_D] == BUTTON_PRESSED)
		{
			vec3 vecInRefFrame = right * movementSpeed * rotMat;

			cam.transformation = glm::translate(cam.transformation, vecInRefFrame);
		}
		if (app->input.keys[K_SPACE] == BUTTON_PRESSED)
		{
			vec3 vecInRefFrame = vec3(0, 1, 0) * movementSpeed * rotMat;

			cam.transformation = glm::translate(cam.transformation, vecInRefFrame);
		}
		if (app->input.keys[K_C] == BUTTON_PRESSED)
		{
			vec3 vecInRefFrame = -vec3(0, 1, 0) * movementSpeed * rotMat;

			cam.transformation = glm::translate(cam.transformation, vecInRefFrame);
		}

		float xIncrease = app->input.mouseDelta.x;
		cam.transformation = glm::rotate(cam.transformation, glm::radians(-xIncrease / 10.0f), vec3(0, 1, 0) * (glm::mat3)cam.transformation);

		float yIncrease = app->input.mouseDelta.y;
		cam.transformation = glm::rotate(cam.transformation, glm::radians(-yIncrease / 10.0f), vec3(1, 0, 0));

		cam.pivot = position + forward * cam.pivotDistance;
	}

	if (app->input.mouseButtons[MIDDLE] == BUTTON_PRESSED)
	{
		float movementSensitivity = 0.01f;

		vec3 right = vec3(cam.transformation[0]);
		vec3 up = vec3(cam.transformation[1]);

		cam.pivot -= right * app->input.mouseDelta.x * movementSensitivity;
		cam.pivot += up * app->input.mouseDelta.y * movementSensitivity;

		cam.transformation[3] = vec4(cam.pivot + vec3(cam.transformation[2]) * cam.pivotDistance, 1);
	}
}

void PushSceneToBuffer(App* app, mat4 projection, mat4 view)
{
	MapBuffer(app->uniformsBuffer, GL_WRITE_ONLY);

	// Push lights to the buffer --------------------------------------------------------------------------------------
	PushVec3(app->uniformsBuffer, (vec3)app->camera.transformation[3]);

	PushUInt(app->uniformsBuffer, app->lightList.size());

	for (Light& light : app->lightList)
	{
		AlignHead(app->uniformsBuffer, sizeof(vec4));

		PushUInt(app->uniformsBuffer, light.type);
		PushUInt(app->uniformsBuffer, light.strength);
		PushVec3(app->uniformsBuffer, light.color);
		PushVec3(app->uniformsBuffer, light.direction);
		PushVec3(app->uniformsBuffer, light.position);
	}

	app->globalParamsSize = app->uniformsBuffer.head;

	// Push entities to the buffer ------------------------------------------------------------------------------------
	for (Entity& entity : app->entityList)
	{
		mat4 worldViewProjection = projection * view * entity.transformationMatrix;

		AlignHead(app->uniformsBuffer, app->uniformBlockAlignment);

		entity.head = app->uniformsBuffer.head;

		PushMat4(app->uniformsBuffer, entity.transformationMatrix);
		PushMat4(app->uniformsBuffer, worldViewProjection);
		PushUInt(app->uniformsBuffer, entity.reflectiveness);

		entity.size = app->uniformsBuffer.head - entity.head;
	}

	UnmapBuffer(app->uniformsBuffer);
}

void Update(App* app)
{
	ProgramHotReload(app);

	Camera& cam = app->camera;
	HandleInput(app, cam);

	// Play with Patricks transforms ----------------------------------------------------------------------------------

	app->entityList.at(0).transformationMatrix = glm::rotate(app->entityList.at(0).transformationMatrix, glm::radians(1.0f), vec3(0, 1, 0));
	app->entityList.at(1).transformationMatrix = TransformPositionScale(vec3(app->entityList.at(0).transformationMatrix[2][0] * 3.0f,
		app->entityList.at(0).transformationMatrix[2][1] * 3.0f,
		app->entityList.at(0).transformationMatrix[2][2] * 3.0f) +
		vec3(0, 1.8, 0),
		vec3(0.3f));
	app->entityList.at(2).transformationMatrix = TransformPositionScale(vec3(0, 1.8, -2.5), vec3(app->entityList.at(0).transformationMatrix[2][0]));

	app->lightList.at(0).position = vec3(app->entityList.at(0).transformationMatrix[2][0] * 5.0f,
		app->entityList.at(0).transformationMatrix[2][1] * 5.0f,
		app->entityList.at(0).transformationMatrix[2][2] * 5.0f) +
		vec3(0, 0.1, 0);

	//-----------------------------------------------------------------------------------------------------------------

	mat4 projection = glm::perspective(glm::radians(cam.fov), cam.aspectRatio, cam.znear, cam.zfar);

	mat4 view = glm::inverse(cam.transformation);

	glm::mat3 skyboxRot = glm::mat3(view);
	glm::mat4 skyboxView = glm::mat4(skyboxRot);

	app->skyboxViewProjection = projection * skyboxView * TransformPositionScale(vec3(0.0f), vec3(cam.zfar / 2));

	PushSceneToBuffer(app, projection, view);

	// Light gizmos need transformation matrices to be displayed on the scene -----------------------------------------
	MapBuffer(app->lightMatricesBuffer, GL_WRITE_ONLY);

	for (Light& light : app->lightList)
	{
		mat4 worldViewProjection = projection * view * TransformPositionScale(light.position, vec3(0.2f));

		AlignHead(app->lightMatricesBuffer, app->uniformBlockAlignment);

		PushMat4(app->lightMatricesBuffer, worldViewProjection);
	}

	UnmapBuffer(app->lightMatricesBuffer);
}

void RenderToQuad(App* app, GLuint textureHandle)
{
	glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	glViewport(0, 0, app->displaySize.x, app->displaySize.y);

	Program& programTexturedGeometry = app->programs[app->texturedGeometryProgramIdx];
	glUseProgram(programTexturedGeometry.handle);
	glBindVertexArray(app->targetQuad_vao);

	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	glUniform1i(app->programUniformTexture, 0);
	glActiveTexture(GL_TEXTURE0);

	glBindTexture(GL_TEXTURE_2D, textureHandle);

	glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, 0);

	glBindVertexArray(0);
	glUseProgram(0);
}

void RenderMeshes(App* app, Program& renderProgram)
{
	glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	glEnable(GL_DEPTH_TEST);
	glUseProgram(renderProgram.handle);

	glBindBufferRange(GL_UNIFORM_BUFFER, 0, app->uniformsBuffer.handle, 0, app->globalParamsSize); //Harcoded at 0 bc it is at the beginning

	glActiveTexture(GL_TEXTURE0);
	switch (app->currentSkybox)
	{
	case 0:		glBindTexture(GL_TEXTURE_CUBE_MAP, app->meadowSkyboxTexIdx); break;
	case 1:		glBindTexture(GL_TEXTURE_CUBE_MAP, app->langholmenSkyboxTexIdx); break;
	case 2:		glBindTexture(GL_TEXTURE_CUBE_MAP, app->SFParkSkyboxTexIdx); break;
	case 3:		glBindTexture(GL_TEXTURE_CUBE_MAP, app->bikiniBottomSkyboxTexIdx); break;
	case 4:		glBindTexture(GL_TEXTURE_CUBE_MAP, app->hornstullsStrandSkyboxTexIdx); break;
	case 5:		glBindTexture(GL_TEXTURE_CUBE_MAP, app->pondSkyboxTexIdx); break;
	case 6:		glBindTexture(GL_TEXTURE_CUBE_MAP, app->powerLinesSkyboxTexIdx); break;
	case 7:		glBindTexture(GL_TEXTURE_CUBE_MAP, app->swedishRoyalCastleSkyboxTexIdx); break;
	case 8:		glBindTexture(GL_TEXTURE_CUBE_MAP, app->yokohamaSkyboxTexIdx); break;
	default:	glBindTexture(GL_TEXTURE_CUBE_MAP, app->meadowSkyboxTexIdx); break;
	}
	glUniform1i(app->renderTexturesProgram_cubeTexture, 0);

	for (Entity& entity : app->entityList)
	{
		Model& model = app->models[entity.model];
		Mesh& mesh = app->meshes[model.meshIdx];

		glBindBufferRange(GL_UNIFORM_BUFFER, 1, app->uniformsBuffer.handle, entity.head, entity.size);

		for (u32 i = 0; i < mesh.submeshes.size(); ++i)
		{
			GLuint vao = FindVAO(mesh, i, renderProgram);
			glBindVertexArray(vao);

			u32 submeshMaterialIdx = model.materialIdx[i];
			Material& submeshMaterial = app->materials[submeshMaterialIdx];

			glActiveTexture(GL_TEXTURE1);
			glBindTexture(GL_TEXTURE_2D, app->textures[submeshMaterial.albedoTextureIdx].handle);
			glUniform1i(app->renderTexturesProgram_uTexture, 1);

			Submesh& submesh = mesh.submeshes[i];
			glDrawElements(GL_TRIANGLES, submesh.indices.size(), GL_UNSIGNED_INT, (void*)(u64)submesh.indexOffset);
		}
	}

	glDisable(GL_DEPTH_TEST);
	glBindVertexArray(0);
	glUseProgram(0);
}

void DeferredLightingPass(App* app)
{
	glViewport(0, 0, app->displaySize.x, app->displaySize.y);

	Program& shadingPassProgram = app->programs[app->deferredLightingProgramIdx];
	glUseProgram(shadingPassProgram.handle);
	glBindVertexArray(app->targetQuad_vao);

	//Bind buffer for global params
	glBindBufferRange(GL_UNIFORM_BUFFER, 0, app->uniformsBuffer.handle, 0, app->globalParamsSize); //Harcoded at 0 bc it is at the beginning

	glUniform1i(app->deferredLightingPass_posTexture, 0);
	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, app->positionAttachmentHandle);

	glUniform1i(app->deferredLightingPass_normalTexture, 1);
	glActiveTexture(GL_TEXTURE1);
	glBindTexture(GL_TEXTURE_2D, app->normalsAttachmentHandle);

	glUniform1i(app->deferredLightingPass_albedoTexture, 2);
	glActiveTexture(GL_TEXTURE2);
	glBindTexture(GL_TEXTURE_2D, app->albedoAttachmentHandle);

	//glDrawBuffer(GL_COLOR_ATTACHMENT3); //Deferred

	GLuint drawBuffers[] = { GL_COLOR_ATTACHMENT3, // Deferred
								 GL_COLOR_ATTACHMENT4 }; // Bright colors
	glDrawBuffers(ARRAY_COUNT(drawBuffers), drawBuffers);

	//glUniform1i(app->deferredLightingPass_brightColors, 4);
	//glActiveTexture(GL_TEXTURE4);
	//glBindTexture(GL_TEXTURE_2D, app->brightColorsAttachmentHandle);

	glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, 0);
	glBindVertexArray(0);
	glUseProgram(0);

	//glBindFramebuffer(GL_FRAMEBUFFER, 0);
}

void RenderLightGizmos(App* app)
{
	Program& lightsVisProgram = app->programs[app->lightVisualizationProgramIdx];
	glUseProgram(lightsVisProgram.handle);

	glBindBufferRange(GL_UNIFORM_BUFFER, 0, app->uniformsBuffer.handle, 0, app->globalParamsSize); //Harcoded at 0 bc it is at the beginning

	for (u32 i = 0; i < app->lightList.size(); ++i)
	{
		Light currentLight = app->lightList[i];

		//Binding and unbinding for each entity is not the most efficient (not batching), but will do
		GLsizei indexAmount;
		if (currentLight.type == LightType_Directional)
		{
			glBindVertexArray(app->cube_vao);
			indexAmount = 36;
		}
		else if (currentLight.type == LightType_Point)
		{
			glBindVertexArray(app->sphere_vao);
			indexAmount = 144;
		}

		glUniform3f(0, currentLight.color.x, currentLight.color.y, currentLight.color.z); //First param is 0 bc it is the only uniform in the shader
		glBindBufferRange(GL_UNIFORM_BUFFER, 0, app->lightMatricesBuffer.handle, i * app->uniformBlockAlignment, app->uniformBlockAlignment);

		glDrawElements(GL_TRIANGLES, indexAmount, GL_UNSIGNED_SHORT, 0);
		glBindVertexArray(0);
	}

	glUseProgram(0);
}

void RenderSkybox(App* app)
{
	glEnable(GL_TEXTURE_CUBE_MAP_SEAMLESS);

	Program& skyboxProgram = app->programs[app->skyboxProgramIdx];
	glUseProgram(skyboxProgram.handle);

	glUniformMatrix4fv(app->skybox_uMatrix, 1, GL_FALSE, glm::value_ptr(app->skyboxViewProjection));

	glBindVertexArray(app->skybox_vao);
	GLsizei indexAmount = 36;

	glUniform1i(app->skybox_uTexture, 0);
	glActiveTexture(GL_TEXTURE0);

	switch (app->currentSkybox)
	{
		case 0:		glBindTexture(GL_TEXTURE_CUBE_MAP, app->meadowSkyboxTexIdx); break;
		case 1:		glBindTexture(GL_TEXTURE_CUBE_MAP, app->langholmenSkyboxTexIdx); break;
		case 2:		glBindTexture(GL_TEXTURE_CUBE_MAP, app->SFParkSkyboxTexIdx); break;
		case 3:		glBindTexture(GL_TEXTURE_CUBE_MAP, app->bikiniBottomSkyboxTexIdx); break;
		case 4:		glBindTexture(GL_TEXTURE_CUBE_MAP, app->hornstullsStrandSkyboxTexIdx); break;
		case 5:		glBindTexture(GL_TEXTURE_CUBE_MAP, app->pondSkyboxTexIdx); break;
		case 6:		glBindTexture(GL_TEXTURE_CUBE_MAP, app->powerLinesSkyboxTexIdx); break;
		case 7:		glBindTexture(GL_TEXTURE_CUBE_MAP, app->swedishRoyalCastleSkyboxTexIdx); break;
		case 8:		glBindTexture(GL_TEXTURE_CUBE_MAP, app->yokohamaSkyboxTexIdx); break;
		default:	glBindTexture(GL_TEXTURE_CUBE_MAP, app->meadowSkyboxTexIdx); break;
	}

	glDrawElements(GL_TRIANGLES, indexAmount, GL_UNSIGNED_SHORT, 0);

	glDisable(GL_TEXTURE_CUBE_MAP_SEAMLESS);
	glBindVertexArray(0);
	glUseProgram(0);
}

void RenderBloom(App* app) 
{
	glViewport(0, 0, app->displaySize.x, app->displaySize.y);

	Program& blurProgram = app->programs[app->blurPassProgramIdx];
	glUseProgram(blurProgram.handle);
	glBindVertexArray(app->targetQuad_vao);

	//Send float and int uniforms
	glUniform1f(app->bloomStrengthLocation, app->bloomStrength);
	glUniform1i(app->bloomIterationsLocation, app->bloomIterations);

	for (int i = 0; i < 10; i++)
	{
		if (i < 5)
		{
			glUniform1i(app->bloom_brightColorImage, 0);
			glActiveTexture(GL_TEXTURE0);
			glBindTexture(GL_TEXTURE_2D, app->brightColorsAttachmentHandle);

			glUniform1i(app->bloom_horizontalLocation, 1); //True

			glDrawBuffer(GL_COLOR_ATTACHMENT5);
		}
		else
		{
			glUniform1i(app->bloom_brightColorImage, 0);
			glActiveTexture(GL_TEXTURE0);
			glBindTexture(GL_TEXTURE_2D, app->halfBlurredColorsAttachmentHandle);

			glUniform1i(app->bloom_horizontalLocation, 0); //False

			glDrawBuffer(GL_COLOR_ATTACHMENT6);
		}
		glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, 0);
	}

	glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, 0);
	glUseProgram(0);

	//--------------------------------------------------------------------------------------------------------------------

	glViewport(0, 0, app->displaySize.x, app->displaySize.y);

	Program& bloomMixProgram = app->programs[app->bloomMixProgramIdx];
	glUseProgram(bloomMixProgram.handle);
	//glBindVertexArray(app->targetQuad_vao);

	glUniform1i(app->bloom_blurredImage, 0);
	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, app->blurredColorsAttachmentHandle);

	glUniform1i(app->bloom_originalImage, 1);
	glActiveTexture(GL_TEXTURE1);
	glBindTexture(GL_TEXTURE_2D, app->deferredAttachmentHandle);


	glDrawBuffer(GL_COLOR_ATTACHMENT7);

	glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_SHORT, 0);
	glUseProgram(0);


	glBindVertexArray(0);
	glBindFramebuffer(GL_FRAMEBUFFER, 0);
}

void PostRenderPass(App* app)
{
	glEnable(GL_DEPTH_TEST);

	//Then we copy the G-Buffer depth to the default depth buffer to render the cubes as if their depth was the scene's.
	glBindFramebuffer(GL_READ_FRAMEBUFFER, app->deferredFrameBufferHandle);
	glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0); // write to default framebuffer
	glBlitFramebuffer(0, 0, app->displaySize.x, app->displaySize.y,
		0, 0, app->displaySize.x, app->displaySize.y,
		GL_DEPTH_BUFFER_BIT, GL_NEAREST
	);

	//We "bind" the default frame buffer
	glBindFramebuffer(GL_FRAMEBUFFER, 0);

	//And then we proceed as usual
	glViewport(0, 0, app->displaySize.x, app->displaySize.y);

	RenderLightGizmos(app);
	RenderSkybox(app);

	glDisable(GL_DEPTH_TEST);
}

void Render(App* app)
{
	switch (app->mode)
	{
	case Mode_TexturedQuad:
	{
		RenderToQuad(app, app->textures[app->diceTexIdx].handle);
	}
	break;
	case Mode_Meshes:
	{
		RenderMeshes(app, app->programs[app->texturedMeshProgramIdx]);
	}
	break;
	case Mode_FrameBuffer:
	{
		//Render on this frame buffer render targets
		glBindFramebuffer(GL_FRAMEBUFFER, app->directFrameBufferHandle);

		//Select on which render targets to draw
		GLuint drawBuffers[] = { app->frameBufferAttachmentHandle };
		glDrawBuffers(ARRAY_COUNT(drawBuffers), drawBuffers);

		RenderMeshes(app, app->programs[app->texturedMeshProgramIdx]);

		glBindFramebuffer(GL_FRAMEBUFFER, 0);
		glDisable(GL_DEPTH_TEST);

		RenderToQuad(app, app->frameBufferAttachmentHandle);

		PostRenderPass(app);
	}
	break;
	case Mode_DeferredRenderTextures:
	{
		//Render on this frame buffer render targets
		glBindFramebuffer(GL_FRAMEBUFFER, app->deferredFrameBufferHandle);

		//Select on which render targets to draw
		GLuint drawBuffers[] = { GL_COLOR_ATTACHMENT0,      //Albedo
								 GL_COLOR_ATTACHMENT1,      //Normals
								 GL_COLOR_ATTACHMENT2 };    //Position
		glDrawBuffers(ARRAY_COUNT(drawBuffers), drawBuffers);

		RenderMeshes(app, app->programs[app->renderTexturesProgramIdx]);

		DeferredLightingPass(app);

		RenderBloom(app);

		GLuint textureHandle = 0;
		switch (app->renderTexMode)
		{
		case RendTexMode_Albedo:   textureHandle = app->albedoAttachmentHandle; break;
		case RendTexMode_Normals:  textureHandle = app->normalsAttachmentHandle; break;
		case RendTexMode_Position: textureHandle = app->positionAttachmentHandle; break;
		case RendTexMode_Depth:    textureHandle = app->depthAttachmentHandle; break;
		case RendTexMode_DeferredOnly: textureHandle = app->deferredAttachmentHandle; break;
		case RendTexMode_DeferredBloom: textureHandle = app->mixedBlurImage; break;
		default: break;
		}

		RenderToQuad(app, textureHandle);

		PostRenderPass(app);
	}
	break;

	default: break;
	}
}
